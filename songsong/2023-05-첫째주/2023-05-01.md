알고리즘 문제를 풀다가 다른 사람 풀이에서
const solution=(a,n)=>a.map((v,i)=>a.length%2^i%2?v+n:v)
'^' 를 보았다. 이게 뭔지 몰라서 찾아보니 비트연산 XOR이라고 한다.

# 비트 연산

- 숫자의 이진 표현을 조작하는 연산
- 비트 연산자는 비트 조작이나 비트 논리와 같은 이진 데이터에 대한 저수준 연산과 관련된 알고리즘 문제를 해결하는 데 유용

## 연산 과정

- 비트 연산이 적용되는 각 숫자는 먼저 이진 표현으로 변환
- 그 다음 두 이진 표현의 해당 비트에서 연산이 수행
- 연산 결과는 십진수 표현으로 다시 변환

## 비트 연산자

1. AND(&): 두 숫자 사이에 비트 AND 연산을 수행, 결과의 각 비트는 두 피연산자의 해당 비트가 1인 경우에만 1로 설정
2. OR(|): 두 숫자 사이에 비트 OR 연산을 수행, 결과의 각 비트는 두 피연산자의 해당 비트 중 하나가 1이면 1로 설정
3. XOR(^): 두 숫자 사이에 비트별 XOR 연산을 수행, 결과의 각 비트는 두 피연산자의 해당 비트가 다른 경우에만 1로 설정
4. NOT(~): 단일 숫자에 대해 비트 단위 NOT 연산을 수행, 이 연산자는 숫자의 모든 비트를 뒤집습니다. 즉, 0을 1로, 1을 0으로 변경
5. 왼쪽 이동(<<): 숫자의 비트를 지정된 위치 수만큼 왼쪽으로 이동, 이는 시프트 양의 거듭제곱으로 증가된 숫자에 2를 곱하는 효과
6. 부호 오른쪽 이동(>>): 원래 숫자의 부호를 유지하면서 지정된 위치 수만큼 숫자의 비트를 오른쪽으로 이동
7. 부호 없는 오른쪽 시프트(>>>): 부호 있는 오른쪽 시프트와 유사하지만 항상 시프트된 위치를 0으로 채워 숫자를 부호 없는 정수로 효과적으로 처리

## 알고리즘 해석

const solution=(a,n)=>a.map((v,i)=>a.length%2^i%2?v+n:v)
XOR 연산에 따라 둘 중 하나만 참일 때 v+n을 반환

- 입력 배열 a의 길이가 짝수이고 인덱스 i가 짝수인 경우.
- 입력 배열 a의 길이가 홀수이고 인덱스 i가 홀수인 경우.

비트 연산자에서는 0 이외의 값은 참, 0은 거짓인 값이 되기 때문에 a.length%2 '== 0' 을 생략해도 된다.
항등 연산자는 비트 연산자에서 쓰지 않는다.

# String.prototype.endsWith()

const solution = (str, suff) => str.endsWith(suff) ? 1 : 0

- 어떤 문자열에서 특정 문자열로 끝나는지를 확인할 때 사용
- 결과는 true/false
